// ------------------------------------
// NetworkManager.js
// ------------------------------------

move = function() {
    if(bInit)
        socket.emit("move", {"position":position, "rotation":rotation});
}
setInterval(move, 100);

var crosshair, crosshairImg, handImg;
        
socket.on('init', function (data)
{
    position = data.player.position;
          
    scene = createScene();
    
    crosshair = document.getElementById("crosshair");
    crosshairImg = document.createElement("img");
    crosshairImg.src = "/static/textures/gui/crosshair.png";
    handImg = document.createElement("img");
    handImg.src = "/static/textures/gui/hand.png";
    crosshair.appendChild(crosshairImg);
    createGUI();
    
    bInit = true;
});

socket.on('teleport', function (data)
{
    teleport(new BABYLON.Vector3(data[0][0], data[0][1], data[0][2]), new BABYLON.Vector3(data[1][0], data[1][1], data[1][2]));
});

teleport = function (pos, rot) {
    if(pos) {
        camera.position = pos;
        ray.origin = camera.position;
    }
    if(rot)
        camera.rotation = rot;
}

var spawnLabel = function(text, player) {
    if(!text)
        text = 'Unnamed';
    //player.name = text;
    let k = 0.2*text.length;
    var plane = BABYLON.Mesh.CreatePlane("outputplane", k, scene, false);
    //plane.scaling.x += text.length;
    plane.billboardMode = BABYLON.AbstractMesh.BILLBOARDMODE_Y;
    plane.material = new BABYLON.StandardMaterial("outputplane", scene);
    plane.position = player.position;
    var planeTexture = new BABYLON.DynamicTexture("dynamic texture", 256, scene, true);
    planeTexture.hasAlpha = true;
    planeTexture.drawText(text, null, 100, 60/k+"px verdana", "black", "transparent");
    plane.material.diffuseTexture = planeTexture;
    plane.material.opacityTexture = planeTexture;
    plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
    plane.material.backFaceCulling = false;
    plane.renderingGroupId = 1;
    player.label = plane;
    return plane;
}

var spawnPlayer = function(data)
{
    if(data.rotation == undefined)
        data.rotation = [0, 0, 0];

    players[data.sid] = clone(1);
    players[data.sid].checkCollisions = false;
    players[data.sid].position = new BABYLON.Vector3(data.position[0], data.position[1], data.position[2]);
    players[data.sid].scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
    players[data.sid].rotation = new BABYLON.Vector3(data.rotation[0], data.rotation[1], data.rotation[2]);

    spawnLabel(data.name, players[data.sid]);
    //label.position = players[data.sid].position;;
    //label.parent = players[data.sid];
    //label.translate(new BABYLON.Vector3(0, -1, 0), 35, BABYLON.Space.LOCAL);
}

var spawnBox = function(data)
{
    var box = new BABYLON.Mesh.CreateBox("crate", 2, scene);
    box.material = new BABYLON.StandardMaterial("Mat", scene);
    box.material.diffuseTexture = new BABYLON.Texture("/static/textures/crate.png", scene);
    //box.material.diffuseTexture.hasAlpha = true;
    box.material.specularColor = new BABYLON.Color3(0, 0, 0);;
    box.position = new BABYLON.Vector3(data.position[0], data.position[1], data.position[2]); 
    box.checkCollisions = true;
    
    return box;
}

var spawnDirectionalLight = function(data)
{
    var light = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(data.direction[0], data.direction[1], data.direction[2]), scene);
    if(data.intensity != undefined)
        light.intensity = data.intensity;
        
    return light;
}

var spawnMesh = function(data)
{
    if(data.rotation == undefined)
        data.rotation = [0, 0, 0];

    BABYLON.SceneLoader.ImportMesh("", "/static/models/"+data.path, data.mesh, scene, function (newMeshes) {
        newMeshes[0].position = new BABYLON.Vector3(data.position[0], data.position[1], data.position[2]);
        newMeshes[0].rotation = new BABYLON.Vector3(data.rotation[0], data.rotation[1], data.rotation[2]);
        
        if(newMeshes[1].skeleton)
        {
            newMeshes[1].skeleton.prepare();
            //isDirty
            scene.beginAnimation(newMeshes[1].skeleton, 0, 360, true);
        }
            
        if(newMeshes[1]) {
            newMeshes[1].position = new BABYLON.Vector3(data.position[0], data.position[1], data.position[2]);
            newMeshes[1].rotation = new BABYLON.Vector3(data.rotation[0], data.rotation[1], data.rotation[2]);
            actors[data.uid] = newMeshes[1];
            newMeshes[1].uniqueId = data.uid;
            newMeshes[0].isVisible = false;
            newMeshes[0].checkCollisions = true;
            shadowGenerator.getShadowMap().renderList.push(newMeshes[1]);
        }
        else {
            actors[data.uid] = newMeshes[0];
            newMeshes[0].uniqueId = data.uid;
            shadowGenerator.getShadowMap().renderList.push(newMeshes[0]);
        }
        //scene.beginAnimation(skeletons[0], 0, 100, true, 1.0);
    });
}

clones = {};

spawnCollision = function(clone, parent) {
    let actor = clone.createInstance("");
    actor.parent = parent;
    actor.isVisible = false;
    actor.checkCollisions = true;
    actor.isPickable = false;
    return actor;
}

spawnActor = function(data) {
	 return;
    let actor, collision;
    //let mesh = assets.items[data[1]].mesh;
    let mesh = assets.actors[data[1]].mesh;
    if(!(mesh in clones)) {
        actor = clone(mesh);
        actor.setEnabled(false);
        if(actor._children) {
            if(actor._children.length == 1)
                collision = actor._children[0];
        }
        clones[mesh] = actor;
    }
    actor = clones[mesh].createInstance("");
    if(clones[mesh]._children) {
        if (clones[mesh]._children.length == 1)
            collision = spawnCollision(clones[mesh]._children[0], actor);
    }
            
    actor.uniqueId = data[0];
    actor.id = data[1];
    actor.position = new BABYLON.Vector3(data[2][0], data[2][1], data[2][2]);
    if(!data[3])
        data[3] = [0, 0 ,0];
    if(!data[4])
        data[4] = [1, 1 ,1];
    actor.rotation = new BABYLON.Vector3(data[3][0], data[3][1], data[3][2]);
    actor.scaling = new BABYLON.Vector3(data[4][0], data[4][1], data[4][2]);
    actor.freezeWorldMatrix();
    //shadowGenerator.getShadowMap().renderList.push(actor);
    shadowList.push(actor);
    if(collision)
        collision.freezeWorldMatrix();
    return actor;
}

socket.on('setActor', function (data) {
    spawnActor(data);
});

socket.on('spawn', function (data)
{
    switch(data.type) {
    case "player":
        spawnPlayer(data);
        break;
    case "box":
        actors[data.uid] = spawnBox(data);
        break;
    case "directionalLight":
        actors[data.uid] = spawnDirectionalLight(data);
        break;
    case "mesh":
        spawnMesh(data);
        break;
    }
});

socket.on('destroy', function (data)
{
    switch(data.type) {
    case "player":
        if(players[data.sid])
        {
            players[data.sid].dispose();
            players[data.sid].label.dispose();
            delete players[data.sid];
        }
        break;
    }
});

socket.on('move', function (data)
{
    //console.log(data.sid);
    //console.log(players);
    if(players[data.sid])
    {
        players[data.sid].position = new BABYLON.Vector3(data.position[0], data.position[1]-1.8, data.position[2]);
        players[data.sid].rotation = new BABYLON.Vector3(0, data.rotation[1], data.rotation[2]);
        //console.log(data.direction);
    }
    //console.log(players[data.sid].position);
});

socket.on('test', function (data)
{
    console.log(data);
});

recompShadows = function() {
    shadowGenerator.getShadowMap().renderList = shadowGenerator.getShadowMap().renderList.concat(shadowList);
    shadowList = [];
    shadowGenerator.getShadowMap().refreshRate = 1;
    shadowGenerator.getShadowMap().refreshRate = 0;
}

// ------------------------------------
// Game.js
// ------------------------------------

var canvas = document.getElementById("renderCanvas");
var engine = new BABYLON.Engine(canvas, true);

var clone = function (id, noCollisions) {
    let mesh = assets.meshes[id];
    var clone = mesh.loadedMeshes[0].clone("");
    clone._scene = scene;
    
    if(mesh.loadedMeshes[1]) {
        var clone1 = mesh.loadedMeshes[1].clone("");
        clone.isVisible = false;
        if(!noCollisions)
            clone.checkCollisions = true;
        clone.isPickable = false;
        clone.parent = clone1;
        clone1._scene = scene;
        scene.addMesh(clone);
        clone = clone1;
    }
    else {
        if(!noCollisions)
            clone.checkCollisions = true;
    }
    
    if(clone.material)
    {
        clone.material._scene = scene;
        if(clone.material.subMaterials)
        {
            for (var i = 0; i < clone.material.subMaterials.length; i++) {
                clone.material.subMaterials[i]._scene = scene;
            }
        }
    }
    scene.addMesh(clone);
    
    return clone;
}
var values = [];
var ray, rayHit;
var traceBlock = 0;
var createScene = function () {
    scene = new BABYLON.Scene(engine);
    /*sun = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(2,-5,5), scene);
    sun.intensity = 3;
    lightSun = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-2,5,-5), scene);
    lightSun.intensity = 1;*/
    //var light0 = new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(0.1, -1, 0.1), scene);
    //var light1 = new BABYLON.DirectionalLight("Dir1", new BABYLON.Vector3(-1, 1, -1), scene);
    //var light1 = new BABYLON.HemisphericLight("Hemi0", new BABYLON.Vector3(0, 1, 0), scene);
    //light1.intensity = 0.5;

    var light0 = new BABYLON.DirectionalLight("Dir0", new BABYLON.Vector3(1, 1, 1), scene);
    var light1 = new BABYLON.DirectionalLight("Dir1", new BABYLON.Vector3(-1, -1, -1), scene);
    light0.intensity = 0.5;
    light1.intensity = 0.5;

    var sun = new BABYLON.DirectionalLight("Dir1", new BABYLON.Vector3(0.5, -1, 0.5), scene);
    //shadowLight.setEnabled(false);

    shadowGenerator = new BABYLON.ShadowGenerator(2048, sun);
    //shadowGenerator.useVarianceShadowMap = true;
    shadowGenerator.useBlurVarianceShadowMap = true;
    shadowGenerator.blurScale = 0.5;
    shadowGenerator.getShadowMap().refreshRate = 0;

    // Terrain material
    mat = new BABYLON.StandardMaterial("", scene);
    txt = new BABYLON.Texture("/static/textures/atlas.png", scene);
    //nor = new BABYLON.Texture("/static/textures/atlas_normal.png", scene);
    mat.diffuseTexture = txt;
    //mat.bumpTexture = nor;
    mat.specularColor = new BABYLON.Color3(0, 0, 0);

    var skybox = BABYLON.Mesh.CreateBox("skyBox", 10000.0, scene);
    var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("/static/textures/skybox/TropicalSunnyDay", scene);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    skybox.material = skyboxMaterial; 
    camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(position[0], position[1], position[2]), scene);
    ray = new BABYLON.Ray(camera.position, new BABYLON.Vector3(0, -1, 0), 100);
    camera.minZ = 0;
    camera.speed = 0.5;
    camera.inertia = 0.8;
    camera.attachControl(canvas, false);
    scene.activeCamera.keysUp.push(87); // W
    scene.activeCamera.keysLeft.push(65); // A 
    scene.activeCamera.keysDown.push(83); // S 
    scene.activeCamera.keysRight.push(68); // D
    
    camera.checkCollisions = true;
    camera.applyGravity = true;

    camera.ellipsoid = new BABYLON.Vector3(0.4, 0.9, 0.4);

    scene.gravity = new BABYLON.Vector3(0, -0.4, 0);

    scene.collisionsEnabled = true;
   
    border = clone(4);
    border.isPickable = false;
    border.checkCollisions = false;
    border.visibility = false;
    border.material.opacityTexture = border.material.diffuseTexture; 
    
    itemL = new Hand(false);
    itemR = new Hand(true);

    BABYLON.SceneLoader.ImportMesh("", "/static/models/strom2/", "strom2.babylon", scene, function (newMeshes) {
        let mesh = newMeshes[0];
        mesh.position = new BABYLON.Vector3(0, 35, 0);
    });

    BABYLON.SceneLoader.ImportMesh("", "/static/models/hand/", "hand.babylon", scene, function (newMeshes) {
        rukaL = newMeshes[0];
        rukaL.renderingGroupId = 1;
        rukaL.parent = camera;
    });
    BABYLON.SceneLoader.ImportMesh("", "/static/models/hand/", "hand.babylon", scene, function (newMeshes) {
        rukaR = newMeshes[0];
        rukaR.renderingGroupId = 1;
        rukaR.scaling.x = -1;
        rukaR.flipFaces();
        rukaR.parent = camera; 
    });

    var oldX = x;
    var oldY = y;
    var deltaX;
    var deltaY;
    var loc = new BABYLON.Vector3(0,0,0);
    //var direction = new BABYLON.Vector3(camera.cameraDirection.x, 0, camera.cameraDirection.z);
    var deltaDir = new BABYLON.Vector3(0,0,0);
    var tick = 0;
    scene.registerBeforeRender(function () {	
        deltaX = x - oldX;
        deltaY = y - oldY;

        if(!bFreeze)
        {        
            if(loc.x + kx*deltaY < Math.PI/2-0.01 && loc.x + kx*deltaY > -Math.PI/2+0.01)
                loc.x += kx*deltaY;
            loc.y += kx*deltaX;
        }

        camera.cameraRotation.x += kx*deltaY*0.5;
        camera.cameraRotation.y += kx*deltaX*0.5;
        camera.cameraRotation.x *= 0.5;
        camera.cameraRotation.y *= 0.5;
        oldX = x;
        oldY = y;
        
        position = [camera.position.x, camera.position.y, camera.position.z];
        rotation = [camera.rotation.x, camera.rotation.y, camera.rotation.z];

        skybox.position.x = camera.position.x;
        skybox.position.z = camera.position.z;

        //fps.innerHTML = engine.getFps().toFixed();
        if(tick % 16 == 0) {
            let value = values.reduce((a, b) => a + b, 0) / values.length;
            fps.innerHTML = parseInt(value);
            values = [];
        }
        else
            values.push(Number(BABYLON.Tools.Format(scene.getLastFrameDuration())));
        //fps.innerHTML = engine.getDeltaTime().toFixed();

        if(tick % 4 == 0) {
            traceHit = trace();
            //rayHit = scene.pickWithRay(ray);
        }
          
        if(traceHit && tick % 4 == 0) {
            if(traceHit.distance <= 7) {
                border.visibility = true;
                border.position = pickBlock();
            }
            else
                border.visibility = false;
            traceHitTick();
        }

        for(let i in players) {
            let player = players[i];
            player.label.position = new BABYLON.Vector3(player.position.x, player.position.y + 2, player.position.z);
            let k = Math.sqrt(BABYLON.Vector3.Distance(camera.position, player.position)) / 4;
            player.label.scaling = new BABYLON.Vector3(k, k, k);
        }

        if(itemL)
            itemL.tick();
        if(itemR)
            itemR.tick();
            
        tick++;
    });
    
    engine.runRenderLoop(function () {
        scene.render();
    });

    // Resize
    window.addEventListener("resize", function () {
        engine.resize();
    });
    
  return scene;
}

//setInterval(function(){ shake(); }, 500);

shake = function (intensity) {
    camera.animations = [];
    var a = new BABYLON.Animation(    "a",    "position.y", 6,    BABYLON.Animation.ANIMATIONTYPE_FLOAT,    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT); // Animation keys
    var keys = [];
    keys.push({ frame: 0, value: camera.position.y });
    keys.push({ frame: 2, value: camera.position.y + intensity});
    keys.push({ frame: 4, value: camera.position.y });
    a.setKeys(keys);

    var easingFunction = new BABYLON.CircleEase();
    easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);

    a.setEasingFunction(easingFunction);
    camera.animations.push(a);
    scene.beginAnimation(camera, 0, 6, false, 2);
}

socket.on('eval', function (data) {
    eval(data);
});

traceHitTick = function() {
    if(typeof traceHit.pickedMesh.id == "number" && traceHit.distance <= 7) {
        if(!assets.actors[traceHit.pickedMesh.id])
            return
        if(assets.actors[traceHit.pickedMesh.id].hand == true) {
            if(crosshair.childNodes[0] == crosshairImg)
                crosshair.replaceChild(handImg, crosshairImg);
        }
        else {
            if(crosshair.childNodes[0] == handImg)
                crosshair.replaceChild(crosshairImg, handImg);
        }
    }
    else {
        if(crosshair.childNodes[0] == handImg)
            crosshair.replaceChild(crosshairImg, handImg);
    }
}

pickBlock = function(add=false) {
    var pos = new BABYLON.Vector3(traceHit.pickedPoint.x, traceHit.pickedPoint.y, traceHit.pickedPoint.z);
    var hit = new BABYLON.Vector3(pos.x.toFixed(10), pos.y.toFixed(10), pos.z.toFixed(10));
    pos.x = Math.floor(hit.x);
    pos.y = Math.ceil(hit.y)-1;
    pos.z = Math.floor(hit.z);
    if(hit.x % 1 == 0) {
        if(add != (camera.position.x > hit.x))
            pos.x -= 1
    }
    if(hit.y % 1 == 0) {
        if(add != (camera.position.y < hit.y))
            pos.y += 1
    }
    if(hit.z % 1 == 0) {
        if(add != (camera.position.z > hit.z))
            pos.z -= 1
    }     
    return pos;
}

setBlock = function(blockPos, id, right) {
    var pos = new BABYLON.Vector3(blockPos.x % 16, blockPos.y, blockPos.z % 16);
    if(pos.x < 0)
        pos.x = 16 + pos.x;
    if(pos.z < 0)
        pos.z = 16 + pos.z;
    var chunk = chunks[String(Math.floor(blockPos.x/16))+'x'+String(Math.floor(blockPos.z/16))];
    worker.postMessage(['update', [chunk.position.x/16, chunk.position.z/16], [pos.x, pos.y, pos.z], id]);
    socket.emit('setBlock', [chunk.uniqueId, pos, right ? slotR : slotL]);
    if(id != 0) take(right);
}

setActor = function(pos, rot, id) {
    pos = [pos.x, pos.y, pos.z];
    rot = [rot.x, rot.y, rot.z];
    var chunk = chunks[String(Math.floor(pos[0]/16))+'x'+String(Math.floor(pos[2]/16))];
    socket.emit('setActor', [chunk.uniqueId, id, pos, rot]);
}

socket.on('destroyActor', function (data) {
    /*let arr = [];
    let dups = [];
    for(let i = 0; i < scene.meshes.length; i++) {
        if(scene.meshes[i].uniqueId in arr)
            dups.push(scene.meshes[i].uniqueId);
        arr.push(scene.meshes[i].uniqueId);
    }*/
    //console.log(dups);
    //console.log('dest', data);
    let mesh = scene.getMeshByUniqueID(data);
    //console.log('mesh', mesh);
    if(!mesh) {
        return;
    }
    mesh.dispose();
    recompShadows();
});

equip = function(right) {
    if(bar.childNodes[num].childNodes[1]) {
        if(right)
            slotR = num;
        else
            slotL = num;
        return equipItem(right, bar.childNodes[num].childNodes[1].dataSlot.id);
    }
    else {
        if(right)
            slotR = undefined;
        else
            slotL = undefined;
        return new Hand(right);
    }
}

window.addEventListener("click", function(e) {
    if(bFreeze)
        return;  
    
    if(e.altKey) {
        if(e.button == 0) {
            if(itemL)
                itemL.destroy();        
            itemL = equip(false);
        }
        if(e.button == 2) {
            if(itemR)
                itemR.destroy();  
            itemR = equip(true);
        }
    }
    else {
        if(e.button == 0) {
            if(e.shiftKey)        
                itemL.click2();
            else
                itemL.click1();
        }
        if(e.button == 2) {
            if(e.shiftKey)        
                itemR.click2();
            else
                itemR.click1();
        }
    }              
});

window.addEventListener("mousedown", function(e) {
    if(e.altKey)
        return;
    if(e.button == 0) {
        holdL = setInterval("itemL.hold()", 100);
        itemL.hold();
    }
    if(e.button == 2) {
        holdR = setInterval("itemR.hold()", 100);
        itemR.hold();
    }
});
window.addEventListener("mouseup", function(e) {
    if(e.button == 0) {
        clearTimeout(holdL);
        itemL.release();
    }
    if(e.button == 2) {
        clearTimeout(holdR);
        itemR.release();
    }
});

window.addEventListener("keypress", function (e) {
      if(bFreeze)
          return;		
		
      var key = e.charCode;
      if(key == 32)
          skok();
});

function trace()
{
    if(scene)
    {
        var pick = scene.pick(canvas.clientWidth/2, canvas.clientHeight/2);
        
        if(pick.pickedMesh)
        {
            return pick;
        }
    }
    return undefined;
}

skok = function () {
    if(scene.pickWithRay(ray).distance > 2)
        return;
    camera.animations = [];
    var a = new BABYLON.Animation(    "a",    "position.y", 6,    BABYLON.Animation.ANIMATIONTYPE_FLOAT,    BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT); // Animation keys
    var keys = [];
    keys.push({ frame: 0, value: camera.position.y });
    keys.push({ frame: 4, value: camera.position.y + 1.1 });
    //keys.push({ frame: 4, value: cam.position.y });  
    a.setKeys(keys);
    
    /*var easingFunction = new BABYLON.CircleEase();
    easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);*/
    
    var easingFunction = new BABYLON.BackEase(0.5);
    easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEOUT);
                      
    a.setEasingFunction(easingFunction);
    camera.animations.push(a);
    scene.beginAnimation(camera, 0, 6, false, 2);
    camera._needMoveForGravity = true;
}
